
package frames;

/*****************************************
* Class Name: ActionFrame
* Purpose: An internal frame that displays an appropriate 
* action corresponding to what space the player landed on.
*******************************************/

import monopoly.engine.Space;
import monopoly.engine.MinorProperty;
import monopoly.engine.MajorProperty;
import monopoly.engine.Game;
import monopoly.engine.Card;
import monopoly.engine.Card;
import java.util.ArrayList;
import java.util.Random;

public class ActionFrame extends javax.swing.JInternalFrame 
{

/*
NAME
        ActionFrame (Constructor)

SYNOPSIS
        ActionFrame(javax.swing.JButton a_endTurnBtn, Game a_currentGame, Space a_currentSpace, javax.swing.JLabel[] a_moneyInd)
    
            a_endTurnBtn  --> The end turn button from the MainGameFrame
            a_currentGame  --> The current game in play
            a_currentSpace --> The space the player is on
            a_moneyInd --> The money indicators from the MainGameFrame

DESCRIPTION
        This constructor is used when a player initially lands on the space.

RETURNS
        Constructor

AUTHOR
        William Ryan
*/
    public ActionFrame(javax.swing.JButton a_endTurnBtn, Game a_currentGame, Space a_currentSpace, javax.swing.JLabel[] a_moneyInd) 
    {
        initComponents();
        m_currentGame = a_currentGame;
        m_currentSpace = a_currentSpace;
        m_endTurn = a_endTurnBtn;
        m_moneyInd = a_moneyInd;
        m_payPlayer = false;
        m_cardDrawn = false;
        m_utilPrice = -1;
        m_card = null;
        continueBtn.setVisible(false);
        roll.setVisible(false);
        utilRoll.setVisible(false);
        bankruptBtn.setVisible(false);
        buyBtn.setVisible(false);
        propertiesBtn.setVisible(false);
        payBtn.setVisible(false);
        auctionBtn.setVisible(false);
        setFrameComponents();
    }
/*
NAME
        ActionFrame (Constructor)

SYNOPSIS
        public ActionFrame(javax.swing.JButton a_endTurnBtn, Game a_currentGame, Space a_currentSpace, javax.swing.JLabel[] a_moneyInd, int a_util) 
    
            a_endTurnBtn  --> The end turn button from the MainGameFrame
            a_currentGame  --> The current game in play
            a_currentSpace --> The space the player is on
            a_moneyInd --> The money indicators from the MainGameFrame
            a_util --> The price of the utility the player landed on
            if the player could not initially pay it

DESCRIPTION
        This constructor is similar to the one above. It is used when a player
        has to mortgage their properties and return to the ActionFrame to pay.

RETURNS
        Constructor

AUTHOR
        William Ryan
*/
    public ActionFrame(javax.swing.JButton a_endTurnBtn, Game a_currentGame, Space a_currentSpace, javax.swing.JLabel[] a_moneyInd, int a_util) 
    {
        initComponents();
        m_currentGame = a_currentGame;
        m_currentSpace = a_currentSpace;
        m_endTurn = a_endTurnBtn;
        m_moneyInd = a_moneyInd;
        m_payPlayer = false;
        m_cardDrawn = false;
        m_utilPrice = a_util;
        m_card = null;
        continueBtn.setVisible(false);
        roll.setVisible(false);
        utilRoll.setVisible(false);
        bankruptBtn.setVisible(false);
        buyBtn.setVisible(false);
        propertiesBtn.setVisible(false);
        payBtn.setVisible(false);
        auctionBtn.setVisible(false);
        
        setFrameComponents();
    }

    /***************************************************************************/
    //The following method was generated by the form editor
    /***************************************************************************/
    
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        payBtn = new javax.swing.JButton();
        continueBtn = new javax.swing.JButton();
        auctionBtn = new javax.swing.JButton();
        buyBtn = new javax.swing.JButton();
        nameLab = new javax.swing.JLabel();
        infoLab = new javax.swing.JLabel();
        utilRoll = new javax.swing.JButton();
        roll = new javax.swing.JLabel();
        bankruptBtn = new javax.swing.JButton();
        propertiesBtn = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        payBtn.setText("Pay");
        payBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                payBtnMousePressed(evt);
            }
        });

        continueBtn.setText("Continue");
        continueBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                continueBtnMousePressed(evt);
            }
        });

        auctionBtn.setText("Auction");
        auctionBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                auctionBtnMousePressed(evt);
            }
        });

        buyBtn.setText("Buy");
        buyBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                buyBtnMousePressed(evt);
            }
        });

        nameLab.setFont(new java.awt.Font("Rockwell", 0, 24)); // NOI18N
        nameLab.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        infoLab.setFont(new java.awt.Font("Rockwell", 0, 18)); // NOI18N
        infoLab.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        infoLab.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        utilRoll.setText("Roll");
        utilRoll.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                utilRollMousePressed(evt);
            }
        });

        roll.setFont(new java.awt.Font("Rockwell", 1, 14)); // NOI18N
        roll.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        bankruptBtn.setText("Declare Bankruptcy");
        bankruptBtn.setActionCommand("");
        bankruptBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                bankruptBtnMousePressed(evt);
            }
        });

        propertiesBtn.setText("Properties");
        propertiesBtn.setToolTipText("");
        propertiesBtn.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                propertiesBtnMousePressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(infoLab, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(nameLab, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(25, 25, 25)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(utilRoll, javax.swing.GroupLayout.DEFAULT_SIZE, 71, Short.MAX_VALUE)
                                    .addComponent(roll, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(auctionBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(33, 33, 33)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(payBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addGap(18, 18, 18)
                                                .addComponent(continueBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 109, javax.swing.GroupLayout.PREFERRED_SIZE))
                                            .addGroup(layout.createSequentialGroup()
                                                .addComponent(propertiesBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 132, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(bankruptBtn)))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 30, Short.MAX_VALUE)
                                        .addComponent(buyBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(16, 16, 16)))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(nameLab, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(infoLab, javax.swing.GroupLayout.PREFERRED_SIZE, 232, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(auctionBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(payBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(continueBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(bankruptBtn)
                                    .addComponent(propertiesBtn))
                                .addGap(0, 15, Short.MAX_VALUE))
                            .addComponent(buyBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(utilRoll, javax.swing.GroupLayout.PREFERRED_SIZE, 53, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(roll, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

/*
NAME
        continueBtnMousePressed

SYNOPSIS
        continueBtnMousePressed(java.awt.event.MouseEvent evt) 
    
            evt  --> The source of the event.

DESCRIPTION
        This method is executed when a player presses the continue button.

RETURNS
        void

AUTHOR
        William Ryan
*/
    private void continueBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_continueBtnMousePressed
        
        //if a card was drawn
        if(m_cardDrawn)
        {
            //get the card type
            switch(m_card.getCardType())
            {
                //if the card instructed the player to move to a space
                case MOVE:
                    //if the player passes go
                    if(m_currentGame.getPlayer(m_currentGame.getTurn()).getPlayerPosition() - m_card.getSpaceToMoveTo() > 0)
                    {
                        //gice the player $200
                        m_currentGame.getPlayer(m_currentGame.getTurn()).addToPlayerMoney(200);
                        m_moneyInd[m_currentGame.getTurn() - 1].setText("Monay: $" + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
                    }
                    //move the player and update the board
                    m_currentGame.movePlayerToSpace(m_currentGame.getTurn(), m_card.getSpaceToMoveTo());
                    MainGameFrame.mainGameFrame.updateBoard();
                    
                    //if the card instructed the player to go to jail
                    if(m_card.getSpaceToMoveTo() == 30)
                    {
                        //put the player in jail
                        m_currentGame.getPlayer(m_currentGame.getTurn()).setPlayerInJail(true);
                        MainGameFrame.mainGameFrame.setPlayerInJail(m_currentGame.getTurn());
                    }
                    //otherwise, start a new ActionFrame based on the space the card moved the player
                    else
                    {
                        ActionFrame newAction = new ActionFrame(m_endTurn, m_currentGame, m_currentGame.getBoard().getSpace(m_card.getSpaceToMoveTo()), m_moneyInd);
                        MainGameFrame.mainGameFrame.addToDeskTopPane(newAction);
                        this.dispose();
                        return;
                    }
            }
        }
        
        //allow the turn to be passed
        m_endTurn.setVisible(true);
        this.dispose();
    }//GEN-LAST:event_continueBtnMousePressed

    //This method executes if a player wishes to auction a property he/she landed on
    private void auctionBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_auctionBtnMousePressed
        // aution the property
        AuctionFrame auction = new AuctionFrame(m_endTurn, m_currentGame, m_currentSpace.getSpaceNum(), m_moneyInd);
        this.getParent().add(auction);
        auction.setVisible(true);
        this.dispose();
        
    }//GEN-LAST:event_auctionBtnMousePressed
/*
NAME
        buyBtnMousePressed

SYNOPSIS
        private void buyBtnMousePressed(java.awt.event.MouseEvent evt)
    
            evt  --> The source of the event.

DESCRIPTION
        This method is executed when a player presses the buy button. It will set the 
        owner to whomever purchased it and set the rent according to how many properties
        of the family type the player owns

RETURNS
        void

AUTHOR
        William Ryan
*/
    private void buyBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_buyBtnMousePressed
        
        // Buy the property
        MinorProperty tempProp = (MinorProperty)m_currentSpace;
        int []propertyNum = tempProp.getPropertyNum(m_currentSpace.getSpaceNum());
        
        //set the property owned to the player who has purchased it and set the rent
        m_currentGame.getPlayer(m_currentGame.getTurn()).buyProperty(propertyNum[0], propertyNum[1], tempProp.getInitialPrice());
        m_currentGame.setPropertyOwned(propertyNum[0], propertyNum[1]);
        m_currentGame.getBoard().getSpace(m_currentSpace.getSpaceNum()).setOwned();
        m_currentGame.getBoard().getSpace(m_currentSpace.getSpaceNum()).setOwner(m_currentGame.getTurn());
        m_currentGame.getBoard().getSpace(m_currentSpace.getSpaceNum()).setCurrentPrice(tempProp.getRent());
        
        //get the property type
        switch(m_propertyType)
        {
            //if the property is a railroad
            case 1:
                //create a temporary railroad used to tell how many railroads the player owns
                boolean rr[] = {false, false, false, false};
                int rrRent = 25;
                int j = 0;
                
                //iterate through each railroad space
                for(int i = 5; i < 36;i = i + 10)
                {
                    MinorProperty railroad = (MinorProperty) m_currentGame.getBoard().getSpace(i);
                    
                    //if the railroad is owned
                    if(railroad.isOwned())
                    {
                        //if the railroad is owned by the current player
                        if(railroad.getOwner() == m_currentGame.getTurn())
                        {
                            //set the temporary railroad to true and increase the property rent
                            rr[j] = true;
                            rrRent = rrRent * 2;
                        }
                    }
                    j++;
                }
                
                //update the rent of all the railroads
                if(rr[0])
                {
                    m_currentGame.getBoard().getMinorProperty(5).setCurrentPrice(rrRent);
                }
                if(rr[1])
                {
                    m_currentGame.getBoard().getMinorProperty(15).setCurrentPrice(rrRent);
                }
                if(rr[2])
                {
                    m_currentGame.getBoard().getMinorProperty(25).setCurrentPrice(rrRent);
                }
                if(rr[3])
                {
                    m_currentGame.getBoard().getMinorProperty(35).setCurrentPrice(rrRent);
                }
                break;
            //if the property is a utility
            case 2:
                //if the player is on electrice company
                if(m_currentSpace.getSpaceNum() == 12)
                {
                    //if the player owns both utilities
                    if(m_currentGame.getBoard().getSpace(28).getOwner() == m_currentGame.getTurn())
                    {
                        //set the rent appropriately
                        m_currentGame.getBoard().getSpace(12).setCurrentPrice(10);
                        m_currentGame.getBoard().getSpace(28).setCurrentPrice(10);
                    }
                    //if the player does not own both utilities
                    else
                    {
                        //set the rent appropriately
                        m_currentGame.getBoard().getSpace(12).setCurrentPrice(4);
                    }
                }
                //if the player is on water works
                else
                {
                    //if the player owns both utilities
                    if(m_currentGame.getBoard().getSpace(12).getOwner() == m_currentGame.getTurn())
                    {
                        //set the rent appropriately
                        m_currentGame.getBoard().getSpace(12).setCurrentPrice(10);
                        m_currentGame.getBoard().getSpace(28).setCurrentPrice(10);
                    }
                    //if the player does not own both utilities
                    else
                    {
                        //set the rent appropriately
                        m_currentGame.getBoard().getSpace(28).setCurrentPrice(4);
                    }
                }
                break;
            //if the property is a normal color property
            default:
                //get the players owned properties
                ArrayList<boolean[]> playerPropFamily = m_currentGame.getPlayer(m_currentGame.getTurn()).getOwnedProperties();
                //temporary ArrayList used to check if the player has aquierd a monopoly
                ArrayList <Integer> properties = new ArrayList<Integer>();
                
                //for each property of the same color of the property being purchased
                for(int i = 0; i < playerPropFamily.get(propertyNum[0]).length;i++)
                {
                    //add it to the players owned properties
                    if(playerPropFamily.get(propertyNum[0])[i])
                    {
                        properties.add(m_currentGame.getBoard().getPropertyNumById(propertyNum[0], i));
                    }
                }
                //if the player has every property of a color
                if(properties.size() == playerPropFamily.get(propertyNum[0]).length)
                {
                    //update the rent to the monopoly rent
                    for(int i = 0; i < properties.size();i++)
                    {
                        m_currentGame.getBoard().getMajorProperty(properties.get(i)).setCurrentPrice(m_currentGame.getBoard().getMajorProperty(properties.get(i)).getMonopolyRent());
                    }
                    m_currentGame.getPlayer(m_currentGame.getTurn()).setMonopoly(propertyNum[0], true);
                }
                break;
        }
        
        //update the players money indicator, allow the player to continue
        m_moneyInd[m_currentGame.getTurn() - 1].setText("Money: " + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
        continueBtn.setVisible(true);
        buyBtn.setVisible(false);
    }//GEN-LAST:event_buyBtnMousePressed
/*
NAME
        payBtnMousePressed

SYNOPSIS
        payBtnMousePressed(java.awt.event.MouseEvent evt)
    
            evt  --> The source of the event.

DESCRIPTION
        This method is executed when a player presses the pay button. It updates
        the players money involed in the transaction. If the player is paying the bank,
        the players money is subtracted appropriately.
RETURNS
        void

AUTHOR
        William Ryan
*/
    private void payBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_payBtnMousePressed
        
        //if the player is paying another player
        if(m_payPlayer)
        {
            m_currentGame.payPlayer(m_currentSpace.getOwner(), m_currentGame.getTurn(), m_currentSpace, m_utilPrice);

            m_moneyInd[m_currentGame.getTurn() - 1].setText("Money: $" + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
            m_moneyInd[m_currentSpace.getOwner() - 1].setText("Money: $" + m_currentGame.getPlayer(m_currentSpace.getOwner()).getMoney());
            
        }
        //if the player is paying the bank
        else
        {
            //if the player has not drawn a card and is paying a tax space
            if(!m_cardDrawn)
            {
                //pay the fee
                m_currentGame.getPlayer(m_currentGame.getTurn()).addToPlayerMoney(-1 * m_currentSpace.getCharge());
                m_moneyInd[m_currentGame.getTurn() - 1].setText("Money: $" + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
            }
            //if the player is paying as result of drawing a card
            else
            {
                //pay the fee
                m_currentGame.getPlayer(m_currentGame.getTurn()).addToPlayerMoney(m_card.getCharge());
                m_moneyInd[m_currentGame.getTurn() - 1].setText("Money: $" + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
            }
        }
        
        //allow the player to proceed
        continueBtn.setVisible(true);
        payBtn.setVisible(false);
    }//GEN-LAST:event_payBtnMousePressed
/*
NAME
        utilRollMousePressed

SYNOPSIS
        utilRollMousePressed(java.awt.event.MouseEvent evt)
    
            evt  --> The source of the event.

DESCRIPTION
        This method is executed when a player presses roll button when rolling
        to pay for a utility.
RETURNS
        void

AUTHOR
        William Ryan
*/
    private void utilRollMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_utilRollMousePressed
        
        Random dice = new Random();
        //get the utility the player is on and genreate a roll
        MinorProperty temp = (MinorProperty) m_currentSpace;
        int playerRoll = dice.nextInt(12) + 1;
        
        roll.setText("Your Roll: " + playerRoll);
        
        m_utilPrice = temp.getRent() * playerRoll;
        
        //if the player cannot pay the rent, instruct him/her to mortgage a property or declare bankcruptcy
        if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() < m_utilPrice)
        {
            infoLab.setText(infoLab.getText() + "<html><br/><br/>Pay $" + m_utilPrice + ", You do not have enough money to pay "
                                                + "the charge<br/>You must mortgage a property, sell a house, or declare bankrupcy");
            propertiesBtn.setVisible(true);
            bankruptBtn.setVisible(true);
        }
        //otherwise, allow the player to pay
        else
        {
            utilRoll.setVisible(false);
            payBtn.setVisible(true);
        
            infoLab.setText(infoLab.getText() + "<html><br/><br/>Pay $" + m_utilPrice + "<html/>");
        }
        
    }//GEN-LAST:event_utilRollMousePressed
    //this method is executed when the player cannot pay and must declare bankcruptcy
    private void bankruptBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_bankruptBtnMousePressed
        //use MainGameFrames declareBankruptcy method to remove the player
        MainGameFrame.mainGameFrame.declareBankruptcy(evt);
        this.dispose();
    }//GEN-LAST:event_bankruptBtnMousePressed

    //this method is executed when a player views his/her properties from the ActionFrame
    private void propertiesBtnMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_propertiesBtnMousePressed
        // display PlayerPropertiesFrame 
        PlayerPropertiesFrame playerProperties = new PlayerPropertiesFrame(m_currentGame, m_currentGame.getTurn(), m_moneyInd, this, m_endTurn, m_utilPrice);
        this.getParent().add(playerProperties);
        playerProperties.setVisible(true);
        this.dispose();
    }//GEN-LAST:event_propertiesBtnMousePressed

/*
NAME
        setFrameComponents

SYNOPSIS
        setFrameComponents()
    
            No parameters.

DESCRIPTION
        This method initializes the frame based on what space was landed on and the 
        status of the current player.
RETURNS
        void

AUTHOR
        William Ryan
*/
   private void setFrameComponents()
   {
       //set the title to the space name
       nameLab.setText(m_currentSpace.getName());
       String actionText = "";
       
       //get the type of space that was landed on
        switch (m_currentSpace.getSpaceType())
        {
            //if the player landed on go
            case GO:
                infoLab.setText("You landed on Go! You collect $200");
                continueBtn.setVisible(true);
                break;
            //if the player landed on a colored property
            case NORMAL:
                MajorProperty tempMaj = (MajorProperty)m_currentSpace;
                m_propertyType = 0;
                
                //if the property is not owned
                if(!m_currentSpace.isOwned())
                {
                    //if the player can afford the property
                    if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() > tempMaj.getInitialPrice())
                    {
                        //allow the player to buy or auction the property
                        actionText = actionText + "<html>This property is not owend yet! Would you like to buy it?<br/><br/>" +
                                     "Price: " + tempMaj.getInitialPrice() + 
                                     "<br/>Rent: " + tempMaj.getRent() + 
                                     tempMaj.getFormatedHouseInfo() + "<html/>";
                        buyBtn.setVisible(true);
                        auctionBtn.setVisible(true);
                    }
                    //if the player cannot afford the property
                    else
                    {
                        //only allow the player to auction it
                        actionText = actionText + "<html>This property is not owend yet but you do not have enough Money to buy it?<br/>The Property Will be auctioned!<br/><br/>" +
                                     "Price: " + tempMaj.getInitialPrice() + 
                                     "<br/>Rent: " + tempMaj.getRent() + 
                                     tempMaj.getFormatedHouseInfo() + "<html/>";
                        auctionBtn.setVisible(true);
                    }
                }
                //if the property is already owned
                else
                {
                    //if the player whos turn it is does not own the property 
                    if(tempMaj.getOwner() != m_currentGame.getTurn())
                    {
                        //if the property is not motgaged
                        if(!tempMaj.isMortgaged())
                        {
                            //if the player can afford the rent
                            if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() > tempMaj.getCurrentPrice())
                            {
                                actionText = actionText + "<html>This property is owend by " + m_currentGame.getPlayerName(tempMaj.getOwner()) +
                                                        "<br/>You must pay $" + tempMaj.getCurrentPrice() + "<html/>";
                                payBtn.setVisible(true);
                                m_payPlayer = true;
                            }
                            //if the player cannot afford the rent
                            else
                            {
                                actionText = actionText + "<html>This property is owend by " + m_currentGame.getPlayerName(tempMaj.getOwner()) +
                                                        "<br/>You must pay $" + tempMaj.getCurrentPrice() + "<br/><br/>You do not have enough money to pay "
                                                        + "the charge<br/>You must mortgage a property, sell a house, or declare bankrupcy<html/>";
                                propertiesBtn.setVisible(true);
                            }
                        }
                        //if the property is mortgaged
                        else
                        {
                            actionText = actionText + "<html>This property is owend by " + m_currentGame.getPlayerName(tempMaj.getOwner()) +
                                                    "<br/>The property is mortgaged." + "<html/>";

                            continueBtn.setVisible(true);

                        }
                    }
                    //if the player already owns the property
                    else
                    {
                        actionText = actionText + "You Own this Property";
                        continueBtn.setVisible(true);
                    }
                }
                
                infoLab.setText(actionText);
                break;
                
            //if the player landed on a railraod
            case RAILROAD:
                
                MinorProperty tempMinRR = (MinorProperty)m_currentSpace;
                m_propertyType = 1;
                
                //if the railroad is not owned
                if(!m_currentSpace.isOwned())
                {
                    //if the player can afford the railroad
                    if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() > tempMinRR.getInitialPrice())
                    {
                        actionText = actionText + "<html>This RailRoad is not owend yet! Would you like to buy it?<br/><br/>" +
                                                  "Price: " + tempMinRR.getInitialPrice() + "<br/>" +
                                                  "Rent For 1 Owned: $25 <br/>Rent For 2 Owned: $50 <br/>Rent For 3 Owned: $100 <br/>Rent For 4 Owned: $200";
                        buyBtn.setVisible(true);
                        auctionBtn.setVisible(true);
                    }
                    //if the player cannot afford the railroad
                    else
                    {
                        actionText = actionText + "<html>This Railroad is not owend yet but you do not have enough Money to buy it?<br/>The Railroad Will be auctioned!<br/><br/>" +
                                     "Price: " + tempMinRR.getInitialPrice() + "<br/>" +
                                     "Rent For 1 Owned: $25 <br/>Rent For 2 Owned: $50 <br/>Rent For 3 Owned: $100 <br/>Rent For 4 Owned: $200";
                        auctionBtn.setVisible(true);
                    }
                }
                //if the railroad is already owned
                else
                {
                    //if the current player does not own the railroad
                    if(tempMinRR.getOwner() != m_currentGame.getTurn())
                    {       
                        //if the railroad is not mortgaged
                        if(!tempMinRR.isMortgaged())
                        {
                            //if the player can afford to pay the rent
                            if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() > tempMinRR.getCurrentPrice())
                            {
                                actionText = actionText + "<html>This Railroad is owend by " + m_currentGame.getPlayerName(tempMinRR.getOwner()) +
                                                    "<br/>You must pay $" + tempMinRR.getCurrentPrice() + "<html/>";
                                payBtn.setVisible(true);
                                m_payPlayer = true;
                            }
                            //if the player cannot afford the rent
                            else
                            {
                                actionText = actionText + "<html>This Railroad is owend by " + m_currentGame.getPlayerName(tempMinRR.getOwner()) +
                                                        "<br/>You must pay $" + tempMinRR.getCurrentPrice() + "<br/><br/>You do not have enough money to pay "
                                                        + "the charge<br/>You must mortgage a property, sell a house, or declare bankrupcy<html/>";
                                propertiesBtn.setVisible(true);
                            }
                        }
                        //if the railroad is mortgaged
                        else
                        {
                            actionText = actionText + "<html>This Railroad is owend by " + m_currentGame.getPlayerName(tempMinRR.getOwner()) +
                                                    "<br/>The property is mortgaged." + "<html/>";
                            continueBtn.setVisible(true);
                        }
                    }
                    //if the current player already owns the railroad
                    else
                    {
                        actionText = actionText + "You Own this RailRoad";
                        continueBtn.setVisible(true);
                    }
                }
                infoLab.setText(actionText);
                break;
                
            //if the player landed on a utility
            case UTILITY:
                MinorProperty tempMinU = (MinorProperty)m_currentSpace;
                m_propertyType = 2;
                
                //if the player is returning from mortgaging properties
                if(m_utilPrice != -1)
                {
                    //if the player cannot afford the price previously rolled 
                    if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() < m_utilPrice)
                    {
                        infoLab.setText(infoLab.getText() + "<html><br/><br/>Pay $" + m_utilPrice + ", You do not have enough money to pay "
                                                + "the charge<br/>You must mortgage a property, sell a house, or declare bankrupcy");
                        propertiesBtn.setVisible(true);
                        bankruptBtn.setVisible(true);
                    }
                    //if the player can afford the price previously rolled 
                    else
                    {
                        infoLab.setText("Pay $" + m_utilPrice);
                        payBtn.setVisible(true);
                    }
                    return;
                }
                //if the player is not returning from mortgaging properties
                else
                {
                    //if the utility is not owned
                    if(!m_currentSpace.isOwned())
                    {
                        //if the player can afford the utility
                        if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() > tempMinU.getInitialPrice())
                        {
                        actionText = actionText + "<html>This Utility is not owend yet! Would you like to buy it?<br/><br/>" +
                                                  "Price: " + tempMinU.getInitialPrice() + "<br/><br/>" + 
                                                  "Rent For 1 Utility: Player rolls dice and pays 4 times the amount shown<br/><br/>"
                                                  + "Rent For 1 Utility: Player rolls dice and pays 10 times the amount shown";

                        continueBtn.setVisible(false);
                        payBtn.setVisible(false);
                        buyBtn.setVisible(true);
                        auctionBtn.setVisible(true);
                        }
                        //if the player cannot afford the utility
                        else
                        {
                            actionText = actionText + "<html>This Utility is not owend yet but you do not have enough Money to buy it?<br/>The Utility Will be auctioned!<br/><br/>" +
                                         "Price: " + tempMinU.getInitialPrice() + "<br/><br/>" + 
                                         "Rent For 1 Utility: Player rolls dice and pays 4 times the amount shown<br/><br/>"
                                        + "Rent For 1 Utility: Player rolls dice and pays 10 times the amount shown";
                            auctionBtn.setVisible(true);
                        }
                    }
                    //if the utility is owned
                    else
                    {
                        //of the current player is not the owner
                        if(tempMinU.getOwner() != m_currentGame.getTurn())
                        {
                            //if the utility is not mortgaged
                            if(!tempMinU.isMortgaged())
                            {

                                    actionText = actionText + "<html>This Utility is owend by " + m_currentGame.getPlayerName(tempMinU.getOwner()) +
                                                        "<br/>Roll the dice and pay " + tempMinU.getCurrentPrice() + " times the ammount shown." + "<html/>";

                                    roll.setVisible(true);
                                    utilRoll.setVisible(true);
                                    m_payPlayer = true;
                            }
                            //if the utility is is mortgaged
                            else
                            {
                                actionText = actionText + "<html>This Utility is owend by " + m_currentGame.getPlayerName(tempMinU.getOwner()) +
                                                        "<br/>The property is mortgaged." + "<html/>";
                                continueBtn.setVisible(true);

                            }
                        }
                        //if the current player already owns the ustility
                        else
                        {
                            actionText = actionText + "You Own this Utility";
                            continueBtn.setVisible(true);
                        }

                    }
                }
                
                infoLab.setText(actionText);
                break;
            //if the player landed on a tax space
            case TAX:
                actionText = actionText + "You landed on " + m_currentSpace.getName() + ", You must pay $" + m_currentSpace.getCharge();
                payBtn.setVisible(true);
                m_payPlayer = false;
                
                infoLab.setText(actionText);
                break;
            //if the player landed on chance
            case CHANCE:
                m_card = m_currentGame.drawFromChance();
                actionText = actionText + "<html>" + m_card.getMessage() + "<html/>";
                m_cardDrawn = true;
                infoLab.setText(actionText);
                //set what happens
                setAction();
                break;
            //if the player landed on a community chest
            case CC:
                m_card = m_currentGame.drawFromCommunityChest();
                actionText = actionText + "<html>" + m_card.getMessage() + "<html/>";
                m_cardDrawn = true;
                infoLab.setText(actionText);
                //set what happens
                setAction();
                break;
            //if the player landed on visiting jail
            case VJAIL:
                buyBtn.setVisible(false);
                payBtn.setVisible(false);
                auctionBtn.setVisible(false);
                buyBtn.setVisible(false);
                continueBtn.setVisible(true);
                break;
            //if the player landed on go to jail
            case JAIL:
                buyBtn.setVisible(false);
                payBtn.setVisible(false);
                auctionBtn.setVisible(false);
                continueBtn.setVisible(true);
                break;
            //if the player landed on free parking
            case FP:
                buyBtn.setVisible(false);
                payBtn.setVisible(false);
                auctionBtn.setVisible(false);
                continueBtn.setVisible(true);
                break;
        }
   }
/*
NAME
        setAction

SYNOPSIS
        setAction()
    
            No parameters.

DESCRIPTION
        This method determines what happens after a player has drawn a community chest
        or chance card.
RETURNS
        void

AUTHOR
        William Ryan
*/
   private void setAction()
   {
       //get the card type
        switch(m_card.getCardType())
        {
            //if the card moves the player
            case MOVE:
                continueBtn.setVisible(true);
                break;
            //if the card gives or takes money from the player
            case CHARGE:
                
                //if the card gives money to the player
                if(m_card.getCharge() > 0)
                {
                    m_currentGame.getPlayer(m_currentGame.getTurn()).addToPlayerMoney(m_card.getCharge());
                    m_moneyInd[m_currentGame.getTurn() - 1].setText("Money: $" + m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney());
                    continueBtn.setVisible(true);
                }
                //if the card charges the player
                else
                {
                    //if the player cannot afford the charge
                    if(m_currentGame.getPlayer(m_currentGame.getTurn()).getMoney() + m_card.getCharge() < 0)
                    {
                        infoLab.setText(infoLab.getText() + "<html><br/><br/>You do not have enough money to pay the charge<br/>You must mortgage a property, sell a house, or declare bankrupcy<html/>");
                        bankruptBtn.setVisible(true);
                    }
                    payBtn.setVisible(true);
                    m_payPlayer = false;
                }
                break;
                
            //if the card gives the player a get out of jail free card
            case GETOUTOFJAIL:
                m_currentGame.getPlayer(m_currentGame.getTurn()).giveGetOutOfJailCard();
                continueBtn.setVisible(true);
                break;
        }
   }
   public Space getcurrentSpace()
   {
        return m_currentSpace;
   }
   
   //Variables generated by the form editor
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton auctionBtn;
    private javax.swing.JButton bankruptBtn;
    private javax.swing.JButton buyBtn;
    private javax.swing.JButton continueBtn;
    private javax.swing.JLabel infoLab;
    private javax.swing.JLabel nameLab;
    private javax.swing.JButton payBtn;
    private javax.swing.JButton propertiesBtn;
    private javax.swing.JLabel roll;
    private javax.swing.JButton utilRoll;
    // End of variables declaration//GEN-END:variables
    //Holds the current game
    private Game m_currentGame;
    //Holds the space the current player is on
    private Space m_currentSpace;
    // m_propertyType --> Used to decide whether the spcae is a normal, minor or major property
    // m_utilPrice --> Used if the space landed on is a utility owned by another player
    //to determine the rent to be paid
    private int m_propertyType, m_utilPrice;
    // m_payPlayer --> Holds true if the player is paying another player rather than the bank
    // m_cardDrawn --> Holds true if a card was drawn
    private boolean m_payPlayer, m_cardDrawn;
    // Holds the card that's been drawn from chance or community chest
    private Card m_card;
    //Holds the players money indicators on the MainGameFrame
    private javax.swing.JLabel[] m_moneyInd;
    //Holds the end turn button on the MainGameFrame
    private javax.swing.JButton m_endTurn;
}
